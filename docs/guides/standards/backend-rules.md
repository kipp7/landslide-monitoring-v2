# 后端规则（必须遵守）

目标：保证“可扩展、不写死、可回放、可运维”。这些规则是架构底线，不随实现阶段妥协。

## 1. 数据入口与幂等

- 设备上报必须先进入 Kafka（削峰），业务 API 不得直接承接设备高频写入。
- 必须具备幂等键（优先）：`device_id + seq`。
  - 若设备端暂时没有 `seq`：用 `device_id + received_ts(秒级) + hash(payload)` 做临时去重，并在 v1.1 补上 `seq`。
- 必须同时记录两种时间：
  - `event_ts`：设备产生时间（不可信，可能漂移/乱序）
  - `received_ts`：服务端接收时间（用于窗口计算、在线判定、乱序修正）
- 数据解析失败、鉴权失败、字段非法不能阻塞主链路：进入 DLQ（死信队列）并可追溯。

## 2. 数据模型（不写死）

- 遥测（telemetry）采用稀疏模型：`metrics` 是 key-value 映射；新增/删除传感器不需要修改表结构。
- 传感器定义必须来自字典表（PostgreSQL `sensors`），前端展示、规则配置以字典表为准。
- 遥测存储不允许把所有字段做“宽表很多列”以免频繁 ALTER TABLE。

## 3. 规则引擎与算法

- 阈值与规则不得硬编码在代码或前端：必须存库，并且版本化（`rule_version`）。
- 规则必须支持：
  - 多传感器 AND/OR 组合
  - 时间窗口（持续 X 分钟/采样点数）
  - 防抖/回差（hysteresis），避免报警抖动
  - 缺失值策略（缺失=忽略/缺失=触发“传感器缺失”类异常）
- AI/预测不允许阻塞写入链路：必须异步（worker/队列），输出可解释结果与置信度。
- 规则可引用算法输出，但算法失败不能导致系统不可用：降级为“不产生预测告警/提示算法不可用”。

## 4. API 契约与前端依赖

- API 必须契约优先（OpenAPI）：前端/Flutter 只依赖 API，不依赖数据库字段。
- 时间统一 RFC3339 UTC；禁止返回本地时区字符串。
- 错误结构统一：`{ code, message, error, traceId }`（字段名与 `integrations/api` 保持一致）。
- 禁止在前端硬编码阈值/设备映射/规则逻辑；这些必须由后端下发/配置。

## 5. 安全（最小但正确）

- 设备身份采用 `device_id + device_secret`（设备端持有明文，服务端只存 hash）。
- MQTT 必须鉴权与 ACL：设备只能发布自己的 topic（`telemetry/{device_id}`），不能越权。
- 所有敏感配置来自环境变量/Secret 文件，不进入仓库。

## 6. 可观测性与降级

- 服务必须输出结构化日志（JSON），包含 `trace_id`/`request_id`。
- 必须有基础指标：
  - ingest 吞吐、Kafka 积压（lag）、写入耗时、规则耗时、告警产出速率、错误率
- 单机容灾思路：以“可恢复”为核心（备份/恢复/runbook），而不是假装高可用。
- 降级策略：
  - 队列积压过大：降低实时推送频率/采样；但不能丢数据
  - ClickHouse 压力大：优先保证写入，查询走聚合/缓存
